/// <reference types="faker" />
declare type SequenceFunction = (counter: number) => unknown;
interface SequenceGenerator {
    generatorType: 'sequence';
    userProvidedFunction: SequenceFunction;
    call: (userProvidedFunction: SequenceFunction, counter: number) => unknown;
}
interface FakerGenerator {
    generatorType: 'faker';
    call: (fake: Faker.FakerStatic) => any;
}
interface PerBuildGenerator {
    generatorType: 'perBuild';
    func: () => any;
    call: (f: () => any) => any;
}
interface OneOfGenerator {
    generatorType: 'oneOf';
    options: any[];
    call: <T>(options: T[]) => T;
}
declare type FieldGenerator = FakerGenerator | SequenceGenerator | OneOfGenerator | PerBuildGenerator;
declare type Field = string | number | null | FieldGenerator | {
    [x: string]: Field | {};
} | any[];
declare type FieldsConfiguration<FactoryResultType> = {
    readonly [x in keyof FactoryResultType]: Field;
};
interface Overrides<FactoryResultType> {
    [x: string]: Field;
}
interface BuildTimeConfig<FactoryResultType> {
    overrides?: Overrides<FactoryResultType>;
    map?: (builtThing: FactoryResultType) => FactoryResultType;
    traits?: string | string[];
}
interface TraitsConfiguration<FactoryResultType> {
    readonly [traitName: string]: {
        overrides?: Overrides<FactoryResultType>;
        postBuild?: (builtThing: FactoryResultType) => FactoryResultType;
    };
}
interface BuildConfiguration<FactoryResultType> {
    readonly fields: FieldsConfiguration<FactoryResultType>;
    readonly traits?: TraitsConfiguration<FactoryResultType>;
    readonly postBuild?: (x: FactoryResultType) => FactoryResultType;
}
export declare const build: <FactoryResultType>(factoryNameOrConfig: string | BuildConfiguration<FactoryResultType>, configObject?: BuildConfiguration<FactoryResultType> | undefined) => (buildTimeConfig?: BuildTimeConfig<FactoryResultType> | undefined) => FactoryResultType;
export declare const oneOf: <T>(...options: T[]) => OneOfGenerator;
export declare const bool: () => OneOfGenerator;
export declare const sequence: (userProvidedFunction?: SequenceFunction) => SequenceGenerator;
export declare const perBuild: <T>(func: () => T) => PerBuildGenerator;
declare type FakerUserArgs = (fake: Faker.FakerStatic) => any;
export declare const fake: (userDefinedUsage: FakerUserArgs) => FakerGenerator;
export {};
//# sourceMappingURL=index.d.ts.map