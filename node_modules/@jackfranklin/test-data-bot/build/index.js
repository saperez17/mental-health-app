"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const faker = __importStar(require("faker"));
const lodash_1 = require("lodash");
const isGenerator = (field) => {
    if (!field)
        return false;
    return field.generatorType !== undefined;
};
const identity = (x) => x;
const buildTimeTraitsArray = (buildTimeConfig) => {
    const { traits = [] } = buildTimeConfig;
    return Array.isArray(traits) ? traits : [traits];
};
exports.build = (factoryNameOrConfig, configObject) => {
    const config = (typeof factoryNameOrConfig === 'string'
        ? configObject
        : factoryNameOrConfig);
    let sequenceCounter = 0;
    const expandConfigFields = (fields, buildTimeConfig = {}) => {
        const finalBuiltThing = lodash_1.mapValues(fields, (fieldValue, fieldKey) => {
            const overrides = buildTimeConfig.overrides || {};
            const traitsArray = buildTimeTraitsArray(buildTimeConfig);
            const traitOverrides = traitsArray.reduce((overrides, currentTraitKey) => {
                const hasTrait = config.traits && config.traits[currentTraitKey];
                if (!hasTrait) {
                    console.warn(`Warning: trait '${currentTraitKey}' not found.`);
                }
                const traitsConfig = config.traits
                    ? config.traits[currentTraitKey]
                    : {};
                return Object.assign(Object.assign({}, overrides), (traitsConfig.overrides || {}));
            }, {});
            const valueOrOverride = overrides[fieldKey] || traitOverrides[fieldKey] || fieldValue;
            /* eslint-disable-next-line @typescript-eslint/no-use-before-define */
            return expandConfigField(valueOrOverride);
        });
        return finalBuiltThing;
    };
    const expandConfigField = (fieldValue) => {
        let calculatedValue;
        if (isGenerator(fieldValue)) {
            switch (fieldValue.generatorType) {
                case 'sequence': {
                    ++sequenceCounter;
                    calculatedValue = fieldValue.call(fieldValue.userProvidedFunction, sequenceCounter);
                    break;
                }
                case 'faker': {
                    calculatedValue = fieldValue.call(faker);
                    break;
                }
                case 'oneOf': {
                    calculatedValue = fieldValue.call(fieldValue.options);
                    break;
                }
                case 'perBuild': {
                    calculatedValue = fieldValue.call(fieldValue.func);
                    break;
                }
            }
        }
        else if (Array.isArray(fieldValue)) {
            calculatedValue = fieldValue.map((v) => expandConfigField(v));
            return calculatedValue;
        }
        else if (fieldValue === null || fieldValue === undefined) {
            // has to be before typeof fieldValue === 'object'
            // as typeof null === 'object'
            calculatedValue = fieldValue;
        }
        else if (typeof fieldValue === 'object') {
            const nestedFieldsObject = fieldValue;
            calculatedValue = expandConfigFields(nestedFieldsObject);
        }
        else {
            calculatedValue = fieldValue;
        }
        return calculatedValue;
    };
    return (buildTimeConfig = {}) => {
        const fieldsToReturn = expandConfigFields(config.fields, buildTimeConfig);
        const traitsArray = buildTimeTraitsArray(buildTimeConfig);
        const traitPostBuilds = traitsArray.map((traitName) => {
            const traitConfig = (config.traits && config.traits[traitName]) || {};
            const postBuild = traitConfig.postBuild || identity;
            return postBuild;
        });
        const afterTraitPostBuildFields = traitPostBuilds.reduce((fields, traitPostBuild) => {
            return traitPostBuild(fields);
        }, fieldsToReturn);
        const postBuild = config.postBuild || identity;
        const buildTimeMapFunc = buildTimeConfig.map || identity;
        return buildTimeMapFunc(postBuild(afterTraitPostBuildFields));
    };
};
exports.oneOf = (...options) => {
    return {
        generatorType: 'oneOf',
        options,
        call: (options) => {
            const randomIndex = Math.floor(Math.random() * options.length);
            return options[randomIndex];
        },
    };
};
exports.bool = () => exports.oneOf(true, false);
exports.sequence = (userProvidedFunction = (x) => x) => {
    return {
        generatorType: 'sequence',
        userProvidedFunction,
        call: (userProvidedFunction, counter) => {
            return userProvidedFunction(counter);
        },
    };
};
exports.perBuild = (func) => {
    return {
        generatorType: 'perBuild',
        func,
        call: (f) => {
            return f();
        },
    };
};
exports.fake = (userDefinedUsage) => {
    return {
        generatorType: 'faker',
        call: (faker) => {
            return userDefinedUsage(faker);
        },
    };
};
//# sourceMappingURL=index.js.map